/*
 * Nodeum API
 *
 * The Nodeum API makes it easy to tap into the digital data mesh that runs across your organisation. Make requests to our API endpoints and we’ll give you everything you need to interconnect your business workflows with your storage.  All production API requests are made to:  http://nodeumhostname/api/  The current production version of the API is v1.   **REST** The Nodeum API is a RESTful API. This means that the API is designed to allow you to get, create, update, & delete objects with the HTTP verbs GET, POST, PUT, PATCH, & DELETE.  **JSON** The Nodeum API speaks exclusively in JSON. This means that you should always set the Content-Type header to application/json to ensure that your requests are properly accepted and processed by the API.  **Authentication** All API calls require user-password authentication.   **Cross-Origin Resource Sharing** The Nodeum API supports CORS for communicating from Javascript for these endpoints. You will need to specify an Origin URI when creating your application to allow for CORS to be whitelisted for your domain.   **Pagination** Some endpoints such as File Listing return a potentially lengthy array of objects. In order to keep the response sizes manageable the API will take advantage of pagination. Pagination is a mechanism for returning a subset of the results for a request and allowing for subsequent requests to “page” through the rest of the results until the end is reached. Paginated endpoints follow a standard interface that accepts two query parameters, limit and offset, and return a payload that follows a standard form. These parameters names and their behavior are borrowed from SQL LIMIT and OFFSET keywords.  **Versioning** The Nodeum API is constantly being worked on to add features, make improvements, and fix bugs. This means that you should expect changes to be introduced and documented.   However, there are some changes or additions that are considered backwards-compatible and your applications should be flexible enough to handle them. These include:  - Adding new endpoints to the API - Adding new attributes to the response of an existing endpoint - Changing the order of attributes of responses (JSON by definition is an object of unordered key/value pairs)  **Filter parameters** When browsing a list of items, multiple filter parameters may be applied. Some operators can be added to the value as a prefix:  - `=` value is equal. Default operator, may be omitted  - `!=` value is different  - `>` greater than  - `>=` greater than or equal  - `<` lower than  - `>=` lower than or equal  - `><` included in list, items should be separated by `|`  - `!><` not included in list, items should be separated by `|`  - `~` pattern matching, may include `%` (any characters) and `_` (one character)  - `!~` pattern not matching, may include `%` (any characters) and `_` (one character)  
 *
 * The version of the OpenAPI document: 2.1.0
 * Contact: info@nodeum.io
 * Generated by: https://openapi-generator.tech
 */

use std::rc::Rc;
use std::borrow::Borrow;
#[allow(unused_imports)]
use std::option::Option;

use hyper;
use serde_json;
use futures::Future;

use super::{Error, configuration};
use super::request as __internal_request;

pub struct FilesApiClient<C: hyper::client::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::Connect> FilesApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> FilesApiClient<C> {
        FilesApiClient {
            configuration,
        }
    }
}

pub trait FilesApi {
    fn files_children(&self, file_parent_id: i32, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>>;
    fn files_children_by_container(&self, container_id: &str, file_parent_id: i32, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>>;
    fn files_children_by_pool(&self, pool_id: &str, file_parent_id: i32, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>>;
    fn files_children_by_task(&self, task_id: &str, file_parent_id: i32, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>>;
    fn files_children_by_task_execution(&self, task_execution_id: &str, file_parent_id: i32, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>>;
    fn files_children_by_task_execution_by_task(&self, task_id: &str, task_execution_id: &str, file_parent_id: i32, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>>;
    fn import_files_children_by_pool(&self, pool_id: &str, file_parent_id: i32, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::ImportFileCollection, Error = Error<serde_json::Value>>>;
    fn index_files(&self, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>>;
    fn index_files_by_container(&self, container_id: &str, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>>;
    fn index_files_by_pool(&self, pool_id: &str, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>>;
    fn index_files_by_task(&self, task_id: &str, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>>;
    fn index_files_by_task_execution(&self, task_execution_id: &str, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>>;
    fn index_files_by_task_execution_by_task(&self, task_id: &str, task_execution_id: &str, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>>;
    fn index_import_files_by_pool(&self, pool_id: &str, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::ImportFileCollection, Error = Error<serde_json::Value>>>;
    fn index_on_tapes_files_by_pool(&self, pool_id: &str, limit: Option<i32>, offset: Option<i32>, name: Option<&str>, _type: Option<&str>, size: Option<&str>) -> Box<dyn Future<Item = crate::models::OnTapesFileCollection, Error = Error<serde_json::Value>>>;
    fn index_tapes_by_file_by_pool(&self, pool_id: &str, file_id: i32) -> Box<dyn Future<Item = crate::models::TapeCollection, Error = Error<serde_json::Value>>>;
    fn index_tapes_by_file_by_task(&self, task_id: &str, file_id: i32) -> Box<dyn Future<Item = crate::models::TapeCollection, Error = Error<serde_json::Value>>>;
    fn index_tapes_by_file_by_task_execution(&self, task_execution_id: &str, file_id: i32) -> Box<dyn Future<Item = crate::models::TapeCollection, Error = Error<serde_json::Value>>>;
    fn index_tapes_by_file_by_task_execution_by_task(&self, task_id: &str, task_execution_id: &str, file_id: i32) -> Box<dyn Future<Item = crate::models::TapeCollection, Error = Error<serde_json::Value>>>;
    fn on_tapes_files_children_by_pool(&self, pool_id: &str, file_parent_id: i32, limit: Option<i32>, offset: Option<i32>, name: Option<&str>, _type: Option<&str>, size: Option<&str>) -> Box<dyn Future<Item = crate::models::OnTapesFileCollection, Error = Error<serde_json::Value>>>;
    fn show_file(&self, file_id: i32) -> Box<dyn Future<Item = crate::models::NodeumFileWithPath, Error = Error<serde_json::Value>>>;
    fn show_file_by_container(&self, container_id: &str, file_id: i32) -> Box<dyn Future<Item = crate::models::NodeumFileWithPath, Error = Error<serde_json::Value>>>;
    fn show_file_by_pool(&self, pool_id: &str, file_id: i32) -> Box<dyn Future<Item = crate::models::NodeumFileWithPath, Error = Error<serde_json::Value>>>;
    fn show_file_by_task(&self, task_id: &str, file_id: i32) -> Box<dyn Future<Item = crate::models::NodeumFileWithPath, Error = Error<serde_json::Value>>>;
    fn show_file_by_task_execution(&self, task_execution_id: &str, file_id: i32) -> Box<dyn Future<Item = crate::models::NodeumFileWithPath, Error = Error<serde_json::Value>>>;
    fn show_file_by_task_execution_by_task(&self, task_id: &str, task_execution_id: &str, file_id: i32) -> Box<dyn Future<Item = crate::models::NodeumFileWithPath, Error = Error<serde_json::Value>>>;
    fn show_import_file_by_pool(&self, pool_id: &str, file_id: i32) -> Box<dyn Future<Item = crate::models::ImportFileWithPath, Error = Error<serde_json::Value>>>;
    fn show_on_tape_file_by_pool(&self, pool_id: &str, file_id: i32) -> Box<dyn Future<Item = crate::models::OnTapesFile, Error = Error<serde_json::Value>>>;
}

impl<C: hyper::client::Connect>FilesApi for FilesApiClient<C> {
    fn files_children(&self, file_parent_id: i32, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/files/{file_parent_id}/children".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = offset {
            req = req.with_query_param("offset".to_string(), s.to_string());
        }
        if let Some(ref s) = file_id {
            req = req.with_query_param("file_id".to_string(), s.to_string());
        }
        if let Some(ref s) = name {
            req = req.with_query_param("name".to_string(), s.to_string());
        }
        if let Some(ref s) = _type {
            req = req.with_query_param("type".to_string(), s.to_string());
        }
        if let Some(ref s) = permission {
            req = req.with_query_param("permission".to_string(), s.to_string());
        }
        if let Some(ref s) = size {
            req = req.with_query_param("size".to_string(), s.to_string());
        }
        if let Some(ref s) = change_date {
            req = req.with_query_param("change_date".to_string(), s.to_string());
        }
        if let Some(ref s) = modification_date {
            req = req.with_query_param("modification_date".to_string(), s.to_string());
        }
        if let Some(ref s) = access_date {
            req = req.with_query_param("access_date".to_string(), s.to_string());
        }
        if let Some(ref s) = gid {
            req = req.with_query_param("gid".to_string(), s.to_string());
        }
        if let Some(ref s) = uid {
            req = req.with_query_param("uid".to_string(), s.to_string());
        }
        req = req.with_path_param("file_parent_id".to_string(), file_parent_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn files_children_by_container(&self, container_id: &str, file_parent_id: i32, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/containers/{container_id}/files/{file_parent_id}/children".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = offset {
            req = req.with_query_param("offset".to_string(), s.to_string());
        }
        if let Some(ref s) = file_id {
            req = req.with_query_param("file_id".to_string(), s.to_string());
        }
        if let Some(ref s) = name {
            req = req.with_query_param("name".to_string(), s.to_string());
        }
        if let Some(ref s) = _type {
            req = req.with_query_param("type".to_string(), s.to_string());
        }
        if let Some(ref s) = permission {
            req = req.with_query_param("permission".to_string(), s.to_string());
        }
        if let Some(ref s) = size {
            req = req.with_query_param("size".to_string(), s.to_string());
        }
        if let Some(ref s) = change_date {
            req = req.with_query_param("change_date".to_string(), s.to_string());
        }
        if let Some(ref s) = modification_date {
            req = req.with_query_param("modification_date".to_string(), s.to_string());
        }
        if let Some(ref s) = access_date {
            req = req.with_query_param("access_date".to_string(), s.to_string());
        }
        if let Some(ref s) = gid {
            req = req.with_query_param("gid".to_string(), s.to_string());
        }
        if let Some(ref s) = uid {
            req = req.with_query_param("uid".to_string(), s.to_string());
        }
        req = req.with_path_param("container_id".to_string(), container_id.to_string());
        req = req.with_path_param("file_parent_id".to_string(), file_parent_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn files_children_by_pool(&self, pool_id: &str, file_parent_id: i32, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/pools/{pool_id}/files/{file_parent_id}/children".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = offset {
            req = req.with_query_param("offset".to_string(), s.to_string());
        }
        if let Some(ref s) = file_id {
            req = req.with_query_param("file_id".to_string(), s.to_string());
        }
        if let Some(ref s) = name {
            req = req.with_query_param("name".to_string(), s.to_string());
        }
        if let Some(ref s) = _type {
            req = req.with_query_param("type".to_string(), s.to_string());
        }
        if let Some(ref s) = permission {
            req = req.with_query_param("permission".to_string(), s.to_string());
        }
        if let Some(ref s) = size {
            req = req.with_query_param("size".to_string(), s.to_string());
        }
        if let Some(ref s) = change_date {
            req = req.with_query_param("change_date".to_string(), s.to_string());
        }
        if let Some(ref s) = modification_date {
            req = req.with_query_param("modification_date".to_string(), s.to_string());
        }
        if let Some(ref s) = access_date {
            req = req.with_query_param("access_date".to_string(), s.to_string());
        }
        if let Some(ref s) = gid {
            req = req.with_query_param("gid".to_string(), s.to_string());
        }
        if let Some(ref s) = uid {
            req = req.with_query_param("uid".to_string(), s.to_string());
        }
        req = req.with_path_param("pool_id".to_string(), pool_id.to_string());
        req = req.with_path_param("file_parent_id".to_string(), file_parent_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn files_children_by_task(&self, task_id: &str, file_parent_id: i32, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/tasks/{task_id}/files/{file_parent_id}/children".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = offset {
            req = req.with_query_param("offset".to_string(), s.to_string());
        }
        if let Some(ref s) = file_id {
            req = req.with_query_param("file_id".to_string(), s.to_string());
        }
        if let Some(ref s) = name {
            req = req.with_query_param("name".to_string(), s.to_string());
        }
        if let Some(ref s) = _type {
            req = req.with_query_param("type".to_string(), s.to_string());
        }
        if let Some(ref s) = permission {
            req = req.with_query_param("permission".to_string(), s.to_string());
        }
        if let Some(ref s) = size {
            req = req.with_query_param("size".to_string(), s.to_string());
        }
        if let Some(ref s) = change_date {
            req = req.with_query_param("change_date".to_string(), s.to_string());
        }
        if let Some(ref s) = modification_date {
            req = req.with_query_param("modification_date".to_string(), s.to_string());
        }
        if let Some(ref s) = access_date {
            req = req.with_query_param("access_date".to_string(), s.to_string());
        }
        if let Some(ref s) = gid {
            req = req.with_query_param("gid".to_string(), s.to_string());
        }
        if let Some(ref s) = uid {
            req = req.with_query_param("uid".to_string(), s.to_string());
        }
        req = req.with_path_param("task_id".to_string(), task_id.to_string());
        req = req.with_path_param("file_parent_id".to_string(), file_parent_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn files_children_by_task_execution(&self, task_execution_id: &str, file_parent_id: i32, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/task_executions/{task_execution_id}/files/{file_parent_id}/children".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = offset {
            req = req.with_query_param("offset".to_string(), s.to_string());
        }
        if let Some(ref s) = file_id {
            req = req.with_query_param("file_id".to_string(), s.to_string());
        }
        if let Some(ref s) = name {
            req = req.with_query_param("name".to_string(), s.to_string());
        }
        if let Some(ref s) = _type {
            req = req.with_query_param("type".to_string(), s.to_string());
        }
        if let Some(ref s) = permission {
            req = req.with_query_param("permission".to_string(), s.to_string());
        }
        if let Some(ref s) = size {
            req = req.with_query_param("size".to_string(), s.to_string());
        }
        if let Some(ref s) = change_date {
            req = req.with_query_param("change_date".to_string(), s.to_string());
        }
        if let Some(ref s) = modification_date {
            req = req.with_query_param("modification_date".to_string(), s.to_string());
        }
        if let Some(ref s) = access_date {
            req = req.with_query_param("access_date".to_string(), s.to_string());
        }
        if let Some(ref s) = gid {
            req = req.with_query_param("gid".to_string(), s.to_string());
        }
        if let Some(ref s) = uid {
            req = req.with_query_param("uid".to_string(), s.to_string());
        }
        req = req.with_path_param("task_execution_id".to_string(), task_execution_id.to_string());
        req = req.with_path_param("file_parent_id".to_string(), file_parent_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn files_children_by_task_execution_by_task(&self, task_id: &str, task_execution_id: &str, file_parent_id: i32, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/tasks/{task_id}/task_executions/{task_execution_id}/files/{file_parent_id}/children".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = offset {
            req = req.with_query_param("offset".to_string(), s.to_string());
        }
        if let Some(ref s) = file_id {
            req = req.with_query_param("file_id".to_string(), s.to_string());
        }
        if let Some(ref s) = name {
            req = req.with_query_param("name".to_string(), s.to_string());
        }
        if let Some(ref s) = _type {
            req = req.with_query_param("type".to_string(), s.to_string());
        }
        if let Some(ref s) = permission {
            req = req.with_query_param("permission".to_string(), s.to_string());
        }
        if let Some(ref s) = size {
            req = req.with_query_param("size".to_string(), s.to_string());
        }
        if let Some(ref s) = change_date {
            req = req.with_query_param("change_date".to_string(), s.to_string());
        }
        if let Some(ref s) = modification_date {
            req = req.with_query_param("modification_date".to_string(), s.to_string());
        }
        if let Some(ref s) = access_date {
            req = req.with_query_param("access_date".to_string(), s.to_string());
        }
        if let Some(ref s) = gid {
            req = req.with_query_param("gid".to_string(), s.to_string());
        }
        if let Some(ref s) = uid {
            req = req.with_query_param("uid".to_string(), s.to_string());
        }
        req = req.with_path_param("task_id".to_string(), task_id.to_string());
        req = req.with_path_param("task_execution_id".to_string(), task_execution_id.to_string());
        req = req.with_path_param("file_parent_id".to_string(), file_parent_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn import_files_children_by_pool(&self, pool_id: &str, file_parent_id: i32, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::ImportFileCollection, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/pools/{pool_id}/import_files/{file_parent_id}/children".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = offset {
            req = req.with_query_param("offset".to_string(), s.to_string());
        }
        if let Some(ref s) = file_id {
            req = req.with_query_param("file_id".to_string(), s.to_string());
        }
        if let Some(ref s) = name {
            req = req.with_query_param("name".to_string(), s.to_string());
        }
        if let Some(ref s) = _type {
            req = req.with_query_param("type".to_string(), s.to_string());
        }
        if let Some(ref s) = permission {
            req = req.with_query_param("permission".to_string(), s.to_string());
        }
        if let Some(ref s) = size {
            req = req.with_query_param("size".to_string(), s.to_string());
        }
        if let Some(ref s) = change_date {
            req = req.with_query_param("change_date".to_string(), s.to_string());
        }
        if let Some(ref s) = modification_date {
            req = req.with_query_param("modification_date".to_string(), s.to_string());
        }
        if let Some(ref s) = access_date {
            req = req.with_query_param("access_date".to_string(), s.to_string());
        }
        if let Some(ref s) = gid {
            req = req.with_query_param("gid".to_string(), s.to_string());
        }
        if let Some(ref s) = uid {
            req = req.with_query_param("uid".to_string(), s.to_string());
        }
        req = req.with_path_param("pool_id".to_string(), pool_id.to_string());
        req = req.with_path_param("file_parent_id".to_string(), file_parent_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn index_files(&self, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/files".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = offset {
            req = req.with_query_param("offset".to_string(), s.to_string());
        }
        if let Some(ref s) = file_id {
            req = req.with_query_param("file_id".to_string(), s.to_string());
        }
        if let Some(ref s) = name {
            req = req.with_query_param("name".to_string(), s.to_string());
        }
        if let Some(ref s) = _type {
            req = req.with_query_param("type".to_string(), s.to_string());
        }
        if let Some(ref s) = permission {
            req = req.with_query_param("permission".to_string(), s.to_string());
        }
        if let Some(ref s) = size {
            req = req.with_query_param("size".to_string(), s.to_string());
        }
        if let Some(ref s) = change_date {
            req = req.with_query_param("change_date".to_string(), s.to_string());
        }
        if let Some(ref s) = modification_date {
            req = req.with_query_param("modification_date".to_string(), s.to_string());
        }
        if let Some(ref s) = access_date {
            req = req.with_query_param("access_date".to_string(), s.to_string());
        }
        if let Some(ref s) = gid {
            req = req.with_query_param("gid".to_string(), s.to_string());
        }
        if let Some(ref s) = uid {
            req = req.with_query_param("uid".to_string(), s.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    fn index_files_by_container(&self, container_id: &str, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/containers/{container_id}/files".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = offset {
            req = req.with_query_param("offset".to_string(), s.to_string());
        }
        if let Some(ref s) = file_id {
            req = req.with_query_param("file_id".to_string(), s.to_string());
        }
        if let Some(ref s) = name {
            req = req.with_query_param("name".to_string(), s.to_string());
        }
        if let Some(ref s) = _type {
            req = req.with_query_param("type".to_string(), s.to_string());
        }
        if let Some(ref s) = permission {
            req = req.with_query_param("permission".to_string(), s.to_string());
        }
        if let Some(ref s) = size {
            req = req.with_query_param("size".to_string(), s.to_string());
        }
        if let Some(ref s) = change_date {
            req = req.with_query_param("change_date".to_string(), s.to_string());
        }
        if let Some(ref s) = modification_date {
            req = req.with_query_param("modification_date".to_string(), s.to_string());
        }
        if let Some(ref s) = access_date {
            req = req.with_query_param("access_date".to_string(), s.to_string());
        }
        if let Some(ref s) = gid {
            req = req.with_query_param("gid".to_string(), s.to_string());
        }
        if let Some(ref s) = uid {
            req = req.with_query_param("uid".to_string(), s.to_string());
        }
        req = req.with_path_param("container_id".to_string(), container_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn index_files_by_pool(&self, pool_id: &str, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/pools/{pool_id}/files".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = offset {
            req = req.with_query_param("offset".to_string(), s.to_string());
        }
        if let Some(ref s) = file_id {
            req = req.with_query_param("file_id".to_string(), s.to_string());
        }
        if let Some(ref s) = name {
            req = req.with_query_param("name".to_string(), s.to_string());
        }
        if let Some(ref s) = _type {
            req = req.with_query_param("type".to_string(), s.to_string());
        }
        if let Some(ref s) = permission {
            req = req.with_query_param("permission".to_string(), s.to_string());
        }
        if let Some(ref s) = size {
            req = req.with_query_param("size".to_string(), s.to_string());
        }
        if let Some(ref s) = change_date {
            req = req.with_query_param("change_date".to_string(), s.to_string());
        }
        if let Some(ref s) = modification_date {
            req = req.with_query_param("modification_date".to_string(), s.to_string());
        }
        if let Some(ref s) = access_date {
            req = req.with_query_param("access_date".to_string(), s.to_string());
        }
        if let Some(ref s) = gid {
            req = req.with_query_param("gid".to_string(), s.to_string());
        }
        if let Some(ref s) = uid {
            req = req.with_query_param("uid".to_string(), s.to_string());
        }
        req = req.with_path_param("pool_id".to_string(), pool_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn index_files_by_task(&self, task_id: &str, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/tasks/{task_id}/files".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = offset {
            req = req.with_query_param("offset".to_string(), s.to_string());
        }
        if let Some(ref s) = file_id {
            req = req.with_query_param("file_id".to_string(), s.to_string());
        }
        if let Some(ref s) = name {
            req = req.with_query_param("name".to_string(), s.to_string());
        }
        if let Some(ref s) = _type {
            req = req.with_query_param("type".to_string(), s.to_string());
        }
        if let Some(ref s) = permission {
            req = req.with_query_param("permission".to_string(), s.to_string());
        }
        if let Some(ref s) = size {
            req = req.with_query_param("size".to_string(), s.to_string());
        }
        if let Some(ref s) = change_date {
            req = req.with_query_param("change_date".to_string(), s.to_string());
        }
        if let Some(ref s) = modification_date {
            req = req.with_query_param("modification_date".to_string(), s.to_string());
        }
        if let Some(ref s) = access_date {
            req = req.with_query_param("access_date".to_string(), s.to_string());
        }
        if let Some(ref s) = gid {
            req = req.with_query_param("gid".to_string(), s.to_string());
        }
        if let Some(ref s) = uid {
            req = req.with_query_param("uid".to_string(), s.to_string());
        }
        req = req.with_path_param("task_id".to_string(), task_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn index_files_by_task_execution(&self, task_execution_id: &str, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/task_executions/{task_execution_id}/files".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = offset {
            req = req.with_query_param("offset".to_string(), s.to_string());
        }
        if let Some(ref s) = file_id {
            req = req.with_query_param("file_id".to_string(), s.to_string());
        }
        if let Some(ref s) = name {
            req = req.with_query_param("name".to_string(), s.to_string());
        }
        if let Some(ref s) = _type {
            req = req.with_query_param("type".to_string(), s.to_string());
        }
        if let Some(ref s) = permission {
            req = req.with_query_param("permission".to_string(), s.to_string());
        }
        if let Some(ref s) = size {
            req = req.with_query_param("size".to_string(), s.to_string());
        }
        if let Some(ref s) = change_date {
            req = req.with_query_param("change_date".to_string(), s.to_string());
        }
        if let Some(ref s) = modification_date {
            req = req.with_query_param("modification_date".to_string(), s.to_string());
        }
        if let Some(ref s) = access_date {
            req = req.with_query_param("access_date".to_string(), s.to_string());
        }
        if let Some(ref s) = gid {
            req = req.with_query_param("gid".to_string(), s.to_string());
        }
        if let Some(ref s) = uid {
            req = req.with_query_param("uid".to_string(), s.to_string());
        }
        req = req.with_path_param("task_execution_id".to_string(), task_execution_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn index_files_by_task_execution_by_task(&self, task_id: &str, task_execution_id: &str, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::NodeumFileCollection, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/tasks/{task_id}/task_executions/{task_execution_id}/files".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = offset {
            req = req.with_query_param("offset".to_string(), s.to_string());
        }
        if let Some(ref s) = file_id {
            req = req.with_query_param("file_id".to_string(), s.to_string());
        }
        if let Some(ref s) = name {
            req = req.with_query_param("name".to_string(), s.to_string());
        }
        if let Some(ref s) = _type {
            req = req.with_query_param("type".to_string(), s.to_string());
        }
        if let Some(ref s) = permission {
            req = req.with_query_param("permission".to_string(), s.to_string());
        }
        if let Some(ref s) = size {
            req = req.with_query_param("size".to_string(), s.to_string());
        }
        if let Some(ref s) = change_date {
            req = req.with_query_param("change_date".to_string(), s.to_string());
        }
        if let Some(ref s) = modification_date {
            req = req.with_query_param("modification_date".to_string(), s.to_string());
        }
        if let Some(ref s) = access_date {
            req = req.with_query_param("access_date".to_string(), s.to_string());
        }
        if let Some(ref s) = gid {
            req = req.with_query_param("gid".to_string(), s.to_string());
        }
        if let Some(ref s) = uid {
            req = req.with_query_param("uid".to_string(), s.to_string());
        }
        req = req.with_path_param("task_id".to_string(), task_id.to_string());
        req = req.with_path_param("task_execution_id".to_string(), task_execution_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn index_import_files_by_pool(&self, pool_id: &str, limit: Option<i32>, offset: Option<i32>, file_id: Option<&str>, name: Option<&str>, _type: Option<&str>, permission: Option<&str>, size: Option<&str>, change_date: Option<&str>, modification_date: Option<&str>, access_date: Option<&str>, gid: Option<&str>, uid: Option<&str>) -> Box<dyn Future<Item = crate::models::ImportFileCollection, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/pools/{pool_id}/import_files".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = offset {
            req = req.with_query_param("offset".to_string(), s.to_string());
        }
        if let Some(ref s) = file_id {
            req = req.with_query_param("file_id".to_string(), s.to_string());
        }
        if let Some(ref s) = name {
            req = req.with_query_param("name".to_string(), s.to_string());
        }
        if let Some(ref s) = _type {
            req = req.with_query_param("type".to_string(), s.to_string());
        }
        if let Some(ref s) = permission {
            req = req.with_query_param("permission".to_string(), s.to_string());
        }
        if let Some(ref s) = size {
            req = req.with_query_param("size".to_string(), s.to_string());
        }
        if let Some(ref s) = change_date {
            req = req.with_query_param("change_date".to_string(), s.to_string());
        }
        if let Some(ref s) = modification_date {
            req = req.with_query_param("modification_date".to_string(), s.to_string());
        }
        if let Some(ref s) = access_date {
            req = req.with_query_param("access_date".to_string(), s.to_string());
        }
        if let Some(ref s) = gid {
            req = req.with_query_param("gid".to_string(), s.to_string());
        }
        if let Some(ref s) = uid {
            req = req.with_query_param("uid".to_string(), s.to_string());
        }
        req = req.with_path_param("pool_id".to_string(), pool_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn index_on_tapes_files_by_pool(&self, pool_id: &str, limit: Option<i32>, offset: Option<i32>, name: Option<&str>, _type: Option<&str>, size: Option<&str>) -> Box<dyn Future<Item = crate::models::OnTapesFileCollection, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/pools/{pool_id}/on_tapes_files".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = offset {
            req = req.with_query_param("offset".to_string(), s.to_string());
        }
        if let Some(ref s) = name {
            req = req.with_query_param("name".to_string(), s.to_string());
        }
        if let Some(ref s) = _type {
            req = req.with_query_param("type".to_string(), s.to_string());
        }
        if let Some(ref s) = size {
            req = req.with_query_param("size".to_string(), s.to_string());
        }
        req = req.with_path_param("pool_id".to_string(), pool_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn index_tapes_by_file_by_pool(&self, pool_id: &str, file_id: i32) -> Box<dyn Future<Item = crate::models::TapeCollection, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/pools/{pool_id}/files/{file_id}/tapes".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("pool_id".to_string(), pool_id.to_string());
        req = req.with_path_param("file_id".to_string(), file_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn index_tapes_by_file_by_task(&self, task_id: &str, file_id: i32) -> Box<dyn Future<Item = crate::models::TapeCollection, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/tasks/{task_id}/files/{file_id}/tapes".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("task_id".to_string(), task_id.to_string());
        req = req.with_path_param("file_id".to_string(), file_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn index_tapes_by_file_by_task_execution(&self, task_execution_id: &str, file_id: i32) -> Box<dyn Future<Item = crate::models::TapeCollection, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/task_executions/{task_execution_id}/files/{file_id}/tapes".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("task_execution_id".to_string(), task_execution_id.to_string());
        req = req.with_path_param("file_id".to_string(), file_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn index_tapes_by_file_by_task_execution_by_task(&self, task_id: &str, task_execution_id: &str, file_id: i32) -> Box<dyn Future<Item = crate::models::TapeCollection, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/tasks/{task_id}/task_executions/{task_execution_id}/files/{file_id}/tapes".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("task_id".to_string(), task_id.to_string());
        req = req.with_path_param("task_execution_id".to_string(), task_execution_id.to_string());
        req = req.with_path_param("file_id".to_string(), file_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn on_tapes_files_children_by_pool(&self, pool_id: &str, file_parent_id: i32, limit: Option<i32>, offset: Option<i32>, name: Option<&str>, _type: Option<&str>, size: Option<&str>) -> Box<dyn Future<Item = crate::models::OnTapesFileCollection, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/pools/{pool_id}/on_tapes_files/{file_parent_id}/children".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = offset {
            req = req.with_query_param("offset".to_string(), s.to_string());
        }
        if let Some(ref s) = name {
            req = req.with_query_param("name".to_string(), s.to_string());
        }
        if let Some(ref s) = _type {
            req = req.with_query_param("type".to_string(), s.to_string());
        }
        if let Some(ref s) = size {
            req = req.with_query_param("size".to_string(), s.to_string());
        }
        req = req.with_path_param("pool_id".to_string(), pool_id.to_string());
        req = req.with_path_param("file_parent_id".to_string(), file_parent_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn show_file(&self, file_id: i32) -> Box<dyn Future<Item = crate::models::NodeumFileWithPath, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/files/{file_id}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("file_id".to_string(), file_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn show_file_by_container(&self, container_id: &str, file_id: i32) -> Box<dyn Future<Item = crate::models::NodeumFileWithPath, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/containers/{container_id}/files/{file_id}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("container_id".to_string(), container_id.to_string());
        req = req.with_path_param("file_id".to_string(), file_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn show_file_by_pool(&self, pool_id: &str, file_id: i32) -> Box<dyn Future<Item = crate::models::NodeumFileWithPath, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/pools/{pool_id}/files/{file_id}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("pool_id".to_string(), pool_id.to_string());
        req = req.with_path_param("file_id".to_string(), file_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn show_file_by_task(&self, task_id: &str, file_id: i32) -> Box<dyn Future<Item = crate::models::NodeumFileWithPath, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/tasks/{task_id}/files/{file_id}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("task_id".to_string(), task_id.to_string());
        req = req.with_path_param("file_id".to_string(), file_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn show_file_by_task_execution(&self, task_execution_id: &str, file_id: i32) -> Box<dyn Future<Item = crate::models::NodeumFileWithPath, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/task_executions/{task_execution_id}/files/{file_id}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("task_execution_id".to_string(), task_execution_id.to_string());
        req = req.with_path_param("file_id".to_string(), file_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn show_file_by_task_execution_by_task(&self, task_id: &str, task_execution_id: &str, file_id: i32) -> Box<dyn Future<Item = crate::models::NodeumFileWithPath, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/tasks/{task_id}/task_executions/{task_execution_id}/files/{file_id}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("task_id".to_string(), task_id.to_string());
        req = req.with_path_param("task_execution_id".to_string(), task_execution_id.to_string());
        req = req.with_path_param("file_id".to_string(), file_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn show_import_file_by_pool(&self, pool_id: &str, file_id: i32) -> Box<dyn Future<Item = crate::models::ImportFileWithPath, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/pools/{pool_id}/import_files/{file_id}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("pool_id".to_string(), pool_id.to_string());
        req = req.with_path_param("file_id".to_string(), file_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn show_on_tape_file_by_pool(&self, pool_id: &str, file_id: i32) -> Box<dyn Future<Item = crate::models::OnTapesFile, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/pools/{pool_id}/on_tapes_files/{file_id}".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "Authorization".to_owned(),
            }))
        ;
        req = req.with_path_param("pool_id".to_string(), pool_id.to_string());
        req = req.with_path_param("file_id".to_string(), file_id.to_string());

        req.execute(self.configuration.borrow())
    }

}
